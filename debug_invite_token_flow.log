============================= test session starts ==============================
platform linux -- Python 3.11.12, pytest-8.3.5, pluggy-1.5.0 -- /usr/local/bin/python3.11
cachedir: .pytest_cache
rootdir: /app
plugins: base-url-2.1.0, playwright-0.4.4
collecting ... collected 35 items

tests/test_app_existing.py::test_create_location PASSED                  [  2%]
tests/test_app_existing.py::test_location_api PASSED                     [  5%]
tests/test_app_existing.py::test_create_aisle PASSED                     [  8%]
tests/test_app_existing.py::test_aisle_api PASSED                        [ 11%]
tests/test_app_existing.py::test_create_store PASSED                     [ 14%]
tests/test_app_existing.py::test_store_api PASSED                        [ 17%]
tests/test_app_existing.py::test_create_master_item PASSED               [ 20%]
tests/test_app_existing.py::test_master_item_api PASSED                  [ 22%]
tests/test_app_existing.py::test_create_inventory PASSED                 [ 25%]
tests/test_app_existing.py::test_inventory_api PASSED                    [ 28%]
tests/test_app_existing.py::test_inventory_requires_auth PASSED          [ 31%]
tests/test_app_existing.py::test_family_inventory_isolation PASSED       [ 34%]
tests/test_auth.py::test_signup_success PASSED                           [ 37%]
tests/test_auth.py::test_signup_duplicate PASSED                         [ 40%]
tests/test_auth.py::test_signup_missing_fields PASSED                    [ 42%]
tests/test_auth.py::test_login_success PASSED                            [ 45%]
tests/test_auth.py::test_login_invalid PASSED                            [ 48%]
tests/test_auth.py::test_logout PASSED                                   [ 51%]
tests/test_family_invite.py::test_signup_with_family PASSED              [ 54%]
tests/test_family_invite.py::test_invite_flow FAILED                     [ 57%]
tests/test_family_invite.py::test_invite_requires_admin FAILED           [ 60%]
tests/test_family_roles.py::test_admin_can_promote_member PASSED         [ 62%]
tests/test_family_roles.py::test_admin_can_demote_other_admin PASSED     [ 65%]
tests/test_family_roles.py::test_admin_cannot_demote_self_if_last_admin PASSED [ 68%]
tests/test_family_roles.py::test_member_cannot_change_roles PASSED       [ 71%]
tests/test_family_user_models.py::test_user_model PASSED                 [ 74%]
tests/test_family_user_models.py::test_family_model PASSED               [ 77%]
tests/test_family_user_models.py::test_family_member_model PASSED        [ 80%]
tests/test_family_user_models.py::test_invitation_model PASSED           [ 82%]
tests/test_ui_playwright.py::test_signup_login_invite_flow FAILED        [ 85%]
tests/test_ui_playwright.py::test_base_nav_ui FAILED                     [ 88%]
tests/test_ui_playwright.py::test_inventory_requires_login_split FAILED  [ 91%]
tests/test_ui_playwright.py::test_inventory_requires_login FAILED        [ 94%]
tests/test_ui_playwright.py::test_inventory_requires_login_each FAILED   [ 97%]
tests/test_ui_playwright_roles.py::test_role_management_ui FAILED        [100%]

=================================== FAILURES ===================================
_______________________________ test_invite_flow _______________________________

client = <FlaskClient <Flask 'app'>>

    def test_invite_flow(client):
        with app.app_context():
            db.drop_all()
            db.create_all()
            admin_id, family_id = create_admin_and_family()
        # Login as admin
        with client.session_transaction() as sess:
            sess['_user_id'] = str(admin_id)
        # Send invite
        rv = client.post('/invite', json={'email': 'invitee@example.com', 'family_id': family_id})
        assert rv.status_code == 200
        token = rv.get_json()['invite_token']
        # Accept invite (simulate visiting link)
        rv = client.get(f'/invite/accept?token={token}')
        assert rv.status_code == 200
        invite_data = rv.get_json()
>       assert invite_data['email'] == 'invitee@example.com'
E       TypeError: 'NoneType' object is not subscriptable

tests/test_family_invite.py:68: TypeError
----------------------------- Captured stdout call -----------------------------
[DEBUG] /invite/accept received token: Imludml0ZWVAZXhhbXBsZS5jb20i.aAj8bw.K0_-i1nraBOAPp26nxK4wiakFF4
[DEBUG] /invite/accept invitation: <Invitation 1>
[DEBUG] /invite/accept invitation status: pending, email: invitee@example.com, family_id: 1
__________________________ test_invite_requires_admin __________________________

client = <FlaskClient <Flask 'app'>>

    def test_invite_requires_admin(client):
        with app.app_context():
            db.drop_all()
            db.create_all()
            admin_id, family_id = create_admin_and_family()
            user = User(email='member@example.com', password_hash='hash')
            db.session.add(user)
            db.session.flush()
            user_id = user.id
            fam_member = FamilyMember(user_id=user_id, family_id=family_id, role='member')
            db.session.add(fam_member)
            db.session.commit()
        # Login as non-admin
        with client.session_transaction() as sess:
            sess['_user_id'] = str(user_id)
        rv = client.post('/invite', json={'email': 'fail@example.com', 'family_id': family_id})
        assert rv.status_code == 403
>       assert 'Only family admin' in rv.get_json()['error']
E       AssertionError: assert 'Only family admin' in 'Only admins can invite.'

tests/test_family_invite.py:98: AssertionError
________________________ test_signup_login_invite_flow _________________________

flask_server = 'http://localhost:36531'

    def test_signup_login_invite_flow(flask_server):
        base_url = flask_server
        setup_test_user("uiadmin@example.com", "pw1234", "UITestFam", base_url)
        with sync_playwright() as p:
            browser = p.chromium.launch()
            page = browser.new_page()
            page.goto(f"{base_url}/family")
>           assert "UITestFam" in page.content()
E           assert 'UITestFam' in '<!DOCTYPE html><html lang="en"><head><title>405 Method Not Allowed</title>\n</head><body><h1>Method Not Allowed</h1>\n<p>The method is not allowed for the requested URL.</p>\n</body></html>'
E            +  where '<!DOCTYPE html><html lang="en"><head><title>405 Method Not Allowed</title>\n</head><body><h1>Method Not Allowed</h1>\n<p>The method is not allowed for the requested URL.</p>\n</body></html>' = content()
E            +    where content = <Page url='http://localhost:36531/login?next=%2Ffamily'>.content

tests/test_ui_playwright.py:118: AssertionError
---------------------------- Captured stdout setup -----------------------------
Attempting to start Flask with: /usr/local/bin/python3.11 /app/app.py on port 36531
Working directory: /app
Environment keys: dict_keys(['COLORTERM', 'PYTHON_SHA256', 'TERM_PROGRAM_VERSION', 'HOSTNAME', 'PYTHON_VERSION', 'SSH_AUTH_SOCK', 'PWD', 'FLASK_RUN_RELOAD', 'VSCODE_GIT_ASKPASS_NODE', 'HOME', 'LANG', 'REMOTE_CONTAINERS', 'GPG_KEY', 'GIT_ASKPASS', 'VSCODE_GIT_ASKPASS_EXTRA_ARGS', 'TERM', 'VSCODE_GIT_IPC_HANDLE', 'FLASK_APP', 'SHLVL', 'PAGER', 'VSCODE_GIT_ASKPASS_MAIN', 'BROWSER', 'PATH', 'FLASK_ENV', 'OLDPWD', 'TERM_PROGRAM', 'VSCODE_IPC_HOOK_CLI', '_', 'PYTEST_VERSION', 'E2E_TEST', 'PYTEST_CURRENT_TEST', 'FLASK_TESTING', 'PORT'])
Flask server started successfully on port 36531.
_______________________________ test_base_nav_ui _______________________________

flask_server = 'http://localhost:36531'

    def test_base_nav_ui(flask_server):
        base_url = flask_server
        setup_test_user("navui@example.com", "pw1234", "NavUITestFam", base_url)
        with sync_playwright() as p:
            browser = p.chromium.launch()
            page = browser.new_page()
            page.goto(f"{base_url}/family")
>           assert "Logged in as navui@example.com" in page.content()
E           assert 'Logged in as navui@example.com' in '<!DOCTYPE html><html lang="en"><head><title>405 Method Not Allowed</title>\n</head><body><h1>Method Not Allowed</h1>\n<p>The method is not allowed for the requested URL.</p>\n</body></html>'
E            +  where '<!DOCTYPE html><html lang="en"><head><title>405 Method Not Allowed</title>\n</head><body><h1>Method Not Allowed</h1>\n<p>The method is not allowed for the requested URL.</p>\n</body></html>' = content()
E            +    where content = <Page url='http://localhost:36531/login?next=%2Ffamily'>.content

tests/test_ui_playwright.py:128: AssertionError
_____________________ test_inventory_requires_login_split ______________________

flask_server = 'http://localhost:36531'

    def test_inventory_requires_login_split(flask_server):
        base_url = flask_server
        with sync_playwright() as p:
            browser = p.chromium.launch()
            page = browser.new_page()
            protected_urls = [
                f"{base_url}/web/inventory",
                f"{base_url}/web/locations",
                f"{base_url}/web/aisles",
                f"{base_url}/web/stores",
                f"{base_url}/web/master-items",
                f"{base_url}/web/shopping-list",
            ]
            for url in protected_urls:
                page.goto(url)
>               page.wait_for_url("**/auth", timeout=5000)

tests/test_ui_playwright.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/playwright/sync_api/_generated.py:8807: in wait_for_url
    self._sync(
/usr/local/lib/python3.11/site-packages/playwright/_impl/_page.py:524: in wait_for_url
    return await self._main_frame.wait_for_url(**locals_to_params(locals()))
/usr/local/lib/python3.11/site-packages/playwright/_impl/_frame.py:233: in wait_for_url
    async with self.expect_navigation(
/usr/local/lib/python3.11/site-packages/playwright/_impl/_event_context_manager.py:33: in __aexit__
    await self._future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def continuation() -> Optional[Response]:
>       event = await waiter.result()
E       playwright._impl._errors.TimeoutError: Timeout 5000ms exceeded.
E       =========================== logs ===========================
E       waiting for navigation to "**/auth" until 'load'
E       ============================================================

/usr/local/lib/python3.11/site-packages/playwright/_impl/_frame.py:208: TimeoutError

During handling of the above exception, another exception occurred:

flask_server = 'http://localhost:36531'

    def test_inventory_requires_login_split(flask_server):
        base_url = flask_server
>       with sync_playwright() as p:

tests/test_ui_playwright.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:90: in __exit__
    self._connection.stop_sync()
/usr/local/lib/python3.11/site-packages/playwright/_impl/_connection.py:280: in stop_sync
    self.cleanup()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x7fe188c751d0>
cause = None

    def cleanup(self, cause: Exception = None) -> None:
        self._closed_error = (
            TargetClosedError(str(cause)) if cause else TargetClosedError()
        )
        if self._init_task and not self._init_task.done():
            self._init_task.cancel()
        for ws_connection in self._child_ws_connections:
            ws_connection._transport.dispose()
        for callback in self._callbacks.values():
>           callback.future.set_exception(self._closed_error)
E           asyncio.exceptions.InvalidStateError: invalid state

/usr/local/lib/python3.11/site-packages/playwright/_impl/_connection.py:296: InvalidStateError
________________________ test_inventory_requires_login _________________________

flask_server = 'http://localhost:36531'

    def test_inventory_requires_login(flask_server):
        base_url = flask_server
        with sync_playwright() as p:
            browser = p.chromium.launch()
            page = browser.new_page()
            protected_urls = [
                f"{base_url}/web/inventory",
                f"{base_url}/web/locations",
                f"{base_url}/web/aisles",
                f"{base_url}/web/stores",
                f"{base_url}/web/master-items",
                f"{base_url}/web/shopping-list",
            ]
            for url in protected_urls:
                page.goto(url)
>               page.wait_for_url("**/auth")

tests/test_ui_playwright.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/playwright/sync_api/_generated.py:8807: in wait_for_url
    self._sync(
/usr/local/lib/python3.11/site-packages/playwright/_impl/_page.py:524: in wait_for_url
    return await self._main_frame.wait_for_url(**locals_to_params(locals()))
/usr/local/lib/python3.11/site-packages/playwright/_impl/_frame.py:233: in wait_for_url
    async with self.expect_navigation(
/usr/local/lib/python3.11/site-packages/playwright/_impl/_event_context_manager.py:33: in __aexit__
    await self._future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def continuation() -> Optional[Response]:
>       event = await waiter.result()
E       playwright._impl._errors.TimeoutError: Timeout 30000ms exceeded.
E       =========================== logs ===========================
E       waiting for navigation to "**/auth" until 'load'
E       ============================================================

/usr/local/lib/python3.11/site-packages/playwright/_impl/_frame.py:208: TimeoutError

During handling of the above exception, another exception occurred:

flask_server = 'http://localhost:36531'

    def test_inventory_requires_login(flask_server):
        base_url = flask_server
>       with sync_playwright() as p:

tests/test_ui_playwright.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:90: in __exit__
    self._connection.stop_sync()
/usr/local/lib/python3.11/site-packages/playwright/_impl/_connection.py:280: in stop_sync
    self.cleanup()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x7fe188b2c490>
cause = None

    def cleanup(self, cause: Exception = None) -> None:
        self._closed_error = (
            TargetClosedError(str(cause)) if cause else TargetClosedError()
        )
        if self._init_task and not self._init_task.done():
            self._init_task.cancel()
        for ws_connection in self._child_ws_connections:
            ws_connection._transport.dispose()
        for callback in self._callbacks.values():
>           callback.future.set_exception(self._closed_error)
E           asyncio.exceptions.InvalidStateError: invalid state

/usr/local/lib/python3.11/site-packages/playwright/_impl/_connection.py:296: InvalidStateError
______________________ test_inventory_requires_login_each ______________________

flask_server = 'http://localhost:36531'

    def test_inventory_requires_login_each(flask_server):
        base_url = flask_server
        with sync_playwright() as p:
            browser = p.chromium.launch()
            page = browser.new_page()
            urls = [
                ("/web/inventory", "Inventory"),
                ("/web/locations", "Locations"),
                ("/web/aisles", "Aisles"),
                ("/web/stores", "Stores"),
                ("/web/master-items", "Master Items"),
                ("/web/shopping-list", "Shopping List"),
            ]
            for path, label in urls:
                url = f"{base_url}{path}"
                page.goto(url)
                try:
>                   page.wait_for_url("**/auth", timeout=5000)

tests/test_ui_playwright.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/playwright/sync_api/_generated.py:8807: in wait_for_url
    self._sync(
/usr/local/lib/python3.11/site-packages/playwright/_impl/_page.py:524: in wait_for_url
    return await self._main_frame.wait_for_url(**locals_to_params(locals()))
/usr/local/lib/python3.11/site-packages/playwright/_impl/_frame.py:233: in wait_for_url
    async with self.expect_navigation(
/usr/local/lib/python3.11/site-packages/playwright/_impl/_event_context_manager.py:33: in __aexit__
    await self._future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def continuation() -> Optional[Response]:
>       event = await waiter.result()
E       playwright._impl._errors.TimeoutError: Timeout 5000ms exceeded.
E       =========================== logs ===========================
E       waiting for navigation to "**/auth" until 'load'
E       ============================================================

/usr/local/lib/python3.11/site-packages/playwright/_impl/_frame.py:208: TimeoutError
----------------------------- Captured stdout call -----------------------------
FAILED: Inventory (http://localhost:36531/web/inventory) did not redirect to /auth.
Exception: Timeout 5000ms exceeded.
=========================== logs ===========================
waiting for navigation to "**/auth" until 'load'
============================================================
HTML: <!DOCTYPE html><html lang="en"><head><title>405 Method Not Allowed</title>
</head><body><h1>Method Not Allowed</h1>
<p>The method is not allowed for the requested URL.</p>
</body></html>
___________________________ test_role_management_ui ____________________________

flask_server = None

    def test_role_management_ui(flask_server):
        debug_port_5000_state("Test start")
        with sync_playwright() as p:
            browser = p.chromium.launch()
            page = browser.new_page()
            try:
                debug_port_5000_state("Before admin signup")
                # DEBUG: Check if user already exists before signup
                import sqlite3
                import os as _os
                db_path = _os.path.join(_os.path.dirname(__file__), '../instance/test.db')
                if _os.path.exists(db_path):
                    with sqlite3.connect(db_path) as conn:
                        cur = conn.cursor()
                        cur.execute("SELECT email FROM user WHERE email=?", ("admin2@example.com",))
                        rows = cur.fetchall()
                        print("DEBUG: Users with email admin2@example.com before signup:", rows)
                else:
                    print("DEBUG: test.db does not exist before signup")
                # Admin signup
                page.goto("http://localhost:5000/auth")
                page.wait_for_timeout(2000)
                page.click("#signup-tab")
                page.wait_for_timeout(2000)
                page.wait_for_selector("#signup", state="visible")
                page.wait_for_timeout(2000)
                page.wait_for_selector("#signupForm", state="visible")
                page.wait_for_timeout(2000)
                # Print signup tab visibility and display style
                signup_tab_visible = page.is_visible("#signup")
                print('DEBUG: #signup tab is_visible:', signup_tab_visible, flush=True)
                signup_tab_display = page.evaluate("window.getComputedStyle(document.querySelector('#signup')).display")
                print('DEBUG: #signup tab display style:', signup_tab_display, flush=True)
                # Print full page content before interacting with fields
                print('DEBUG: FULL PAGE HTML before field interaction:', page.content(), flush=True)
                page.wait_for_timeout(2000)
                # Wait for any tab transitions/animations to finish
                page.wait_for_timeout(2000)
                # Ensure fields are editable BEFORE filling
                signup_email_editable = page.is_editable("#signupEmail")
                signup_password_editable = page.is_editable("#signupPassword")
>               signup_family_editable = page.is_editable("#signupFamily")

tests/test_ui_playwright_roles.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/playwright/sync_api/_generated.py:7923: in is_editable
    self._sync(
/usr/local/lib/python3.11/site-packages/playwright/_impl/_page.py:388: in is_editable
    return await self._main_frame.is_editable(**locals_to_params(locals()))
/usr/local/lib/python3.11/site-packages/playwright/_impl/_frame.py:339: in is_editable
    return await self._channel.send("isEditable", locals_to_params(locals()))
/usr/local/lib/python3.11/site-packages/playwright/_impl/_connection.py:59: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x7fe188da3490>
cb = <function Channel.send.<locals>.<lambda> at 0x7fe188cef060>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.is_editable: Timeout 30000ms exceeded.
E           Call log:
E           waiting for locator("#signupFamily")

/usr/local/lib/python3.11/site-packages/playwright/_impl/_connection.py:513: TimeoutError
---------------------------- Captured stdout setup -----------------------------
[DEBUG] Before server start: Checking port 5000...
[DEBUG] Before server start: Port 5000 is FREE.
[DEBUG] After server start: Checking port 5000...
[DEBUG] After server start: Port 5000 is FREE.
FLASK APP STARTED: TESTING = True ENV = {'COLORTERM': 'truecolor', 'PYTHON_SHA256': '849da87af4df137710c1796e276a955f7a85c9f971081067c8f565d15c352a09', 'TERM_PROGRAM_VERSION': '1.97.0', 'HOSTNAME': 'f11cc52a690f', 'PYTHON_VERSION': '3.11.12', 'SSH_AUTH_SOCK': '/root/.windsurf-server/.69a900001328c5e276063fc33dcff89076073a54-ssh-auth.sock', 'PWD': '/app', 'FLASK_RUN_RELOAD': 'true', 'VSCODE_GIT_ASKPASS_NODE': '/root/.windsurf-server/bin/69a900001328c5e276063fc33dcff89076073a54/node', 'HOME': '/root', 'LANG': 'C.UTF-8', 'REMOTE_CONTAINERS': 'true', 'GPG_KEY': 'A035C8C19219BA821ECEA86B64E628F8D684696D', 'GIT_ASKPASS': '/root/.windsurf-server/bin/69a900001328c5e276063fc33dcff89076073a54/extensions/git/dist/askpass.sh', 'VSCODE_GIT_ASKPASS_EXTRA_ARGS': '', 'TERM': 'xterm-256color', 'VSCODE_GIT_IPC_HANDLE': '/tmp/vscode-git-0c9406c158.sock', 'FLASK_APP': 'app.py', 'SHLVL': '1', 'PAGER': 'cat', 'VSCODE_GIT_ASKPASS_MAIN': '/root/.windsurf-server/bin/69a900001328c5e276063fc33dcff89076073a54/extensions/git/dist/askpass-main.js', 'BROWSER': '/root/.windsurf-server/bin/69a900001328c5e276063fc33dcff89076073a54/bin/helpers/browser.sh', 'PATH': '/root/.windsurf-server/bin/69a900001328c5e276063fc33dcff89076073a54/bin/remote-cli:/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin', 'FLASK_ENV': 'development', 'OLDPWD': '/root/.windsurf-server/bin/69a900001328c5e276063fc33dcff89076073a54', 'TERM_PROGRAM': 'vscode', 'VSCODE_IPC_HOOK_CLI': '/tmp/vscode-ipc-fff2803b-172d-4770-8546-ab12c2b7e424.sock', '_': '/usr/local/bin/pytest', 'PYTEST_VERSION': '8.3.5', 'E2E_TEST': '1', 'PYTEST_CURRENT_TEST': 'tests/test_ui_playwright_roles.py::test_role_management_ui (setup)', 'FLASK_TESTING': '1'}
 * Serving Flask app 'app'
 * Debug mode: off
---------------------------- Captured stderr setup -----------------------------
[31m[1mWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.[0m
 * Running on http://127.0.0.1:5000
[33mPress CTRL+C to quit[0m
127.0.0.1 - - [23/Apr/2025 14:44:04] "GET /auth HTTP/1.1" 200 -
----------------------------- Captured stdout call -----------------------------
[DEBUG] Test start: Checking port 5000...
[DEBUG] Test start: Port 5000 is IN USE: [Errno 98] Address already in use
[DEBUG] Before admin signup: Checking port 5000...
[DEBUG] Before admin signup: Port 5000 is IN USE: [Errno 98] Address already in use
DEBUG: Users with email admin2@example.com before signup: []
DEBUG: #signup tab is_visible: True
DEBUG: #signup tab display style: block
DEBUG: FULL PAGE HTML before field interaction: <!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <title>Home Inventory</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-light bg-light mb-4">
    <div class="container-fluid">
      <a class="navbar-brand" href="/">Home Inventory</a>
      <div>
        <a class="nav-link d-inline" href="/web/locations">Locations</a>
        <a class="nav-link d-inline" href="/web/master-items">Master Items</a>
        <a class="nav-link d-inline" href="/web/inventory">Inventory</a>
        <a class="nav-link d-inline" href="/web/stores">Stores</a>
        <a class="nav-link d-inline" href="/web/aisles">Aisles</a>
        <a class="nav-link d-inline" href="/web/shopping-list">Shopping List</a>
        
          <a class="nav-link d-inline" href="/auth">Login</a>
        
      </div>
    </div>
  </nav>
  <div class="container">
    
<div class="row justify-content-center">
  <div class="col-md-6 col-lg-5">
    <ul class="nav nav-tabs mb-3" id="authTabs" role="tablist">
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="login-tab" data-bs-toggle="tab" data-bs-target="#login" type="button" role="tab" aria-selected="false" tabindex="-1">Login</button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link active" id="signup-tab" data-bs-toggle="tab" data-bs-target="#signup" type="button" role="tab" aria-selected="true">Sign Up</button>
      </li>
    </ul>
    <div class="tab-content" id="authTabsContent">
      <div class="tab-pane fade" id="login" role="tabpanel" aria-labelledby="login-tab">
        <form id="loginForm" method="post">
          <div class="mb-3">
            <label for="loginEmail" class="form-label">Email</label>
            <input type="email" class="form-control" id="loginEmail" name="email" required="">
          </div>
          <div class="mb-3">
            <label for="loginPassword" class="form-label">Password</label>
            <input type="password" class="form-control" id="loginPassword" name="password" required="">
          </div>
          <button class="btn btn-primary w-100" type="submit">Login</button>
          <div id="loginError" class="alert alert-danger mt-3 d-none"></div>
        </form>
      </div>
      <div class="tab-pane fade active show" id="signup" role="tabpanel" aria-labelledby="signup-tab">
        <form id="signupForm" method="post">
          <div class="mb-3">
            <label for="signupEmail" class="form-label">Email</label>
            <input type="email" class="form-control" id="signupEmail" name="email">
          </div>
          <div class="mb-3">
            <label for="signupPassword" class="form-label">Password</label>
            <input type="password" class="form-control" id="signupPassword" name="password" required="">
          </div>
          <div class="mb-3">
            <label for="signupFamilyName" class="form-label">Family Name <small class="text-muted">(optional if joining by invite)</small></label>
            <input type="text" class="form-control" id="signupFamilyName" name="family_name">
          </div>
          <div class="mb-3">
            <label for="signupInvite" class="form-label">Invitation Token <small class="text-muted">(optional, if joining by invite)</small></label>
            <input type="text" class="form-control" id="signupInvite" name="invite_token">
          </div>
          <button class="btn btn-success w-100" type="submit">Sign Up</button>
          <div id="signupError" class="alert alert-danger mt-3 d-none"></div>
          
        </form>
      </div>
    </div>
  </div>
</div>
<script>
const loginForm = document.getElementById('loginForm');
const signupForm = document.getElementById('signupForm');
loginForm.onsubmit = async (e) => {
  e.preventDefault();
  const email = loginForm.email.value;
  const password = loginForm.password.value;
  const resp = await fetch('/login', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({email, password})
  });
  if (resp.ok) {
    window.location = '/family';
  } else {
    const data = await resp.json();
    document.getElementById('loginError').textContent = data.error;
    document.getElementById('loginError').classList.remove('d-none');
  }
};
signupForm.onsubmit = async (e) => {
  e.preventDefault();
  const email = signupForm.email.value;
  const password = signupForm.password.value;
  const family_name = signupForm.family_name.value;
  const invite_token = signupForm.invite_token.value;
  const payload = {email, password};
  if (family_name) payload.family_name = family_name;
  if (invite_token) payload.invite_token = invite_token;
  const resp = await fetch('/signup', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(payload)
  });
  if (resp.ok) {
    window.location = '/family';
  } else {
    const data = await resp.json();
    document.getElementById('signupError').textContent = data.error;
    document.getElementById('signupError').classList.remove('d-none');
  }
};
// On page load, switch to signup tab if invite_token is present
window.addEventListener('DOMContentLoaded', function() {
  const inviteToken = document.getElementById('signupInvite').value;
  if (inviteToken) {
    var signupTab = document.getElementById('signup-tab');
    if (signupTab) signupTab.click();
    // If email is not prefilled, try to extract from token via backend
    const emailInput = document.getElementById('signupEmail');
    if (emailInput && !emailInput.value) {
      // Try to fetch the invite email from a hidden field or data attribute
      const inviteEmail = emailInput.getAttribute('data-invite-email');
      if (inviteEmail) {
        emailInput.value = inviteEmail;
        emailInput.readOnly = true;
      }
    }
  }
});
</script>

  </div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body></html>
[DEBUG] Test end: Checking port 5000...
[DEBUG] Test end: Port 5000 is IN USE: [Errno 98] Address already in use
----------------------------- Captured stderr call -----------------------------
127.0.0.1 - - [23/Apr/2025 14:44:05] "GET /auth HTTP/1.1" 200 -
--------------------------- Captured stdout teardown ---------------------------
[DEBUG] After server stop: Checking port 5000...
[DEBUG] After server stop: Port 5000 is FREE.
DEBUG: test.db deleted after session
=============================== warnings summary ===============================
tests/test_app_existing.py: 35 warnings
tests/test_auth.py: 1 warning
tests/test_family_invite.py: 3 warnings
tests/test_family_roles.py: 4 warnings
  /app/app.py:128: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    return User.query.get(int(user_id))

tests/test_app_existing.py: 20 warnings
  /usr/local/lib/python3.11/site-packages/flask_login/utils.py:126: DeprecationWarning: 'werkzeug.urls.url_decode' is deprecated and will be removed in Werkzeug 2.4. Use 'urllib.parse.parse_qs' instead.
    md = url_decode(parsed_result.query)

tests/test_app_existing.py: 20 warnings
  /usr/local/lib/python3.11/site-packages/flask_login/utils.py:130: DeprecationWarning: 'werkzeug.urls.url_encode' is deprecated and will be removed in Werkzeug 2.4. Use 'urllib.parse.urlencode' instead.
    netloc=netloc, query=url_encode(md, sort=True)

tests/test_family_invite.py::test_signup_with_family
  /app/tests/test_family_invite.py:49: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    family = Family.query.get(fam_member.family_id)

tests/test_family_invite.py::test_invite_flow
  /app/app.py:651: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    family = Family.query.get(invitation.family_id)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/test_family_invite.py::test_invite_flow - TypeError: 'NoneType' ...
FAILED tests/test_family_invite.py::test_invite_requires_admin - AssertionErr...
FAILED tests/test_ui_playwright.py::test_signup_login_invite_flow - assert 'U...
FAILED tests/test_ui_playwright.py::test_base_nav_ui - assert 'Logged in as n...
FAILED tests/test_ui_playwright.py::test_inventory_requires_login_split - asy...
FAILED tests/test_ui_playwright.py::test_inventory_requires_login - asyncio.e...
FAILED tests/test_ui_playwright.py::test_inventory_requires_login_each - play...
FAILED tests/test_ui_playwright_roles.py::test_role_management_ui - playwrigh...
============ 8 failed, 27 passed, 85 warnings in 142.01s (0:02:22) =============
